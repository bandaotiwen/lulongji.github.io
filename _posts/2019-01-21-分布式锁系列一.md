---
layout:     post
title:      Distributed lock series [redis] 
subtitle:   redis方案
date:       2019-01-21
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - lock
---


# 说明

目前实现分布式锁机制的流行方案有三种，基于redis的、基于数据库的、基于zookeeper的。


# redis使用锁说明

redis能用的的加锁命令分表是INCR、SETNX、SET

- INCR 
 
当key不存在的时候，那么key的值会被初始化为0，然后在执行INCR操作进行加一，然后其他用户在执行INCR的时候进行加一，如果返回的数大于一，那么说明这个锁正在被使用当中。

    1、 客户端A请求服务器获取key的值为1表示获取了锁
    2、 客户端B也去请求服务器获取key的值为2表示获取锁失败
    3、 客户端A执行代码完成，删除锁
    4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功
    5、 客户端B执行代码完成，删除锁

    $redis->incr($key);
    $redis->expire($key, $ttl); 


- SETNX

当key不存在的时候，将key设置成value，如果key已存在，则SETNX不做任何动作。

    1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功
    2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败
    3、 客户端A执行代码完成，删除锁
    4、 客户端B在等待一段时间后在去请求设置key的值，设置成功
    5、 客户端B执行代码完成，删除锁

    $redis->setNX($key, $value);
    $redis->expire($key, $ttl);

- SET （ 2.6.12 后）

和上面不同的是SET操作不需要设置expire的过期时间，上面两个操作如果不设置过期时间，那么可能会出现某个请求因为意外执行退出后没有删除（释放）锁，以至于后续缓存不会更新。

    1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功
    2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败
    3、 客户端A执行代码完成，删除锁
    4、 客户端B在等待一段时间后在去请求设置key的值，设置成功
    5、 客户端B执行代码完成，删除锁

    $redis->set($key, $value, array('nx', 'ex' => $ttl)); 


# 单进程锁方案

单机版锁方案，除了乐观锁外，其他的大同小异，一般都是设置一个变量 ：

    boolean isAccessible = true;

当A线程访问Target时，先要去看isAccessible是否为true，如果为true，则获取访问权，同时将isAccessible设置为false； 此时如果B线程也去访问Target，则发现isAccessible为false，因而获取不到访问权限，那么B线程可以while循环判断isAccessible直到该变量为true时获取访问权； 当一个线程访问完后，将标记isAccessible设为true。 值得注意的是，要保证以上过程正确执行必须满足两个条件： 

    第一、isAccessible必须保证各个线程都可见， 
    第二、作为标记的变量的判断和修改需要是原子操作！ 

首先，可以使用volatile关键字保证其多线程可见性，其次，可以使用java中原子对象例如AtomicBoolean对象及其compareAndSet方法来保证原子操作。 

# 分布式锁方案


首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：
1. 互斥性。在任意时刻，只有一个客户端能持有锁。
2. 不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。
3. 具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。
4. 解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。

实现思路
1. 获取锁的时候，使用setnx加锁，并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。
2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。
3. 释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放。

    redis命令（SETNX、expire、delete）

问题

    基于redis分布式锁方案，会有一个问题，那就是```单点故障```（Redis的master节点宕机了）。主从方案无法保证安全互斥，因为Redis的复制是异步的。（需要一个高可用方案）

- 开源 redisson 实现分布式锁(只能保证客户端的正确，却无法保证服务端的宕机数据丢失)

- 基于redlock的算法讨论(数据完整性很高，但是管理起来很复杂)

这种我还没有具体实现过，为什么会出现这种算法，主要是应对redis服务器宕机的问题。当redis宕机时，即使有主从，但是依然会有一个同步间隔。这样就会造成数据流失。

当然，更为严重的是，在分布式情况下，丢失的是锁，我们知道一般用锁的数据都是比较重要的。

一个场景：A在向主机1请求到锁成功后，主机1宕机了。现在从机1a变成了主机。但是数据没有同步，从机1a是没有A的锁的。那么B又可以获得一个锁。这样就会造成数据错误。

redlock主要思想就是做数据冗余。建立5台独立的集群，当我们发送一个数据的时候，要保证3台（n/2+1）以上的机器接受成功才算成功，否则重试或报错。

当然具体是很复杂，想研究的可以看看（https://redis.io/topics/distlock）



# 声明
本文只做学习参考，如有任何问题的地方欢迎指正。

我的邮箱：
- ```lulongji2011@163.com``