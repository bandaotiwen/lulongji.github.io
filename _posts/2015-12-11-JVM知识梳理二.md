---
layout:     post
title:      JVM知识点梳理二
subtitle:   内存可见性、重排序、顺序一致性、volatile、锁、final
date:       2015-12-11
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - JVM
---

# 内存可见性
什么是内存可见性？

让我们先看一个栗子：

        package com.lulj.web.volatiletest;

        /**
        * Created by lu on 2019/1/29.
        */
        public class TestVolatile {

            public static void main(String[] args) {
                ThreadDemo td = new ThreadDemo();
                new Thread(td).start();
                while (true) {
                    if (td.isFlag()) {
                        System.out.println("--------------");
                        break;
                    }
                }
            }


            static class ThreadDemo implements Runnable {
                private  boolean flag = false;

                @Override
                public void run() {
                    try {
                        Thread.sleep(200);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    flag = true;
                    System.out.println("flag = " + isFlag());
                }

                public boolean isFlag() {
                    return flag;
                }

                public void setFlag(boolean flag) {
                    this.flag = flag;
                }
            }
        }


程序的运行结果：

    flag = true

并且程序不会终止，为什么会这样呢？

当程序运行时，```JVM会为每一个执行任务的线程分配一个独立的缓存空间，用来提高效率```。当程序开始执行的时候，在flag = true之前 Thread.sleep(200);这样td线程和main线程获取的flag=false，这不难理解；```重点来了,在接下来的执行过程中， while (true) 是执行效率很高的，这样main线程就没有时间再次从主存中获取flag的值。```


        1.初始化 
            main线程获取到主存中flag=false ==> main独立缓存 flag=false
            td线程获取到主存中flag=false   ==> td独立缓存 flag=false 

        2.改变值
            main线程改变flag=true  ==>main独立缓存获取 flag=true
            
        3.同步
            main线程同步主存flag=true ==> 主存 flag=true


```注意：while (true) 执行速度非常快，没有时间再次获取主存数据```所以导致死循环。