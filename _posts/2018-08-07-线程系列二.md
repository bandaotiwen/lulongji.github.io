---
layout:     post
title:      线程系列二
subtitle:   synchronized使用
date:       2018-08-07
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - synchronized
    - 线程
---

# synchronized

### 方发锁

synchronized 修饰方法时锁定的是调用该方法的对象。它并不能使调用该方法的多个对象在执行顺序上互斥。

实例：

    public class Test implements Runnable{
        private String name;
    //    private static MethodSync methodSync = new MethodSync();
        private MethodSync methodSync = new MethodSync();
        
        public Test(String name){
            this.name = name;
        }
        
        @Override
        public void run() {
            methodSync.method(name);
        }
        
        public static void main(String[] args) {
            Thread t1 = new Thread(new Test("test 1"));
            Thread t2 = new Thread(new Test("test 2"));
            t1.start();
            t2.start();
        }
    }

```上面创建了二个Test类的对象，相当于启动了两个线程， 这两个线程将会并发地执行它们的run方法中的代码。```
<br />

MethodSync.java ,该类只拥有一个用来测试的 synchronized 方法:

    public class MethodSync {
        
        /*
        * @Task : 测试 synchronized 修饰方法时锁定的是调用该方法的对象
        * @param name  线程的标记名称
        */
        public synchronized void method(String name){
            System.out.println(name + " Start a sync method");
            try{
                Thread.sleep(300);
            }catch(InterruptedException e){}
            System.out.println(name + " End the sync method");
        }
    }

先看执行结果：

    test 1 Start a sync method
    test 2 Start a sync method
    test 1 End the sync method
    test 2 End the sync method


```test1 先于 test2 执行 同步方法，但是却后于 test2 结束。这里并没有达到互斥的效果！原因是：MethodSync是实例变量，每次创建一个Test对象就会创建一个MethodSync对象， synchronized 只会锁定调用method()方法的那个MethodSync对象，而这里创建的两个线程分别拥有两个不同的MethodSync对象，它们调用method方法时就没有互斥关系。```


当把Test.java 中的MethodSync 变量 用 static 来修饰时，执行结果如下：

    test 1 Start a sync method
    test 1 End the sync method
    test 2 Start a sync method
    test 2 End the sync method

```这里，正确实现了同步作用。原因如下：这里也创建了二个线程(Test 对象)，但是每个Test对象共享MethodSync 变量，也即只有一个MethodSync 变量在两个线程中执行 method方法，这样两个线程在执行到method 方法这段代码时就会形成互斥。```

 

### 代码块锁

不要认为给方法或者代码段加上synchronized就万事大吉。

实例：

    class Sync {

        public synchronized void test() {
            System.out.println("test开始..");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("test结束..");
        }
    }

    class MyThread extends Thread {

        public void run() {
            Sync sync = new Sync();
            sync.test();
        }
    }


    class Main {

        public static void main(String[] args) {
            for (int i = 0; i < 3; i++) {
                Thread thread = new MyThread();
                thread.start();
            }
        }
    }

结果：

    test开始..
    test开始..
    test开始..
    test结束..
    test结束..
    test结束..

    Process finished with exit code 0


```可以看出来，上面的程序起了三个线程，同时运行Sync类中的test()方法，虽然test()方法加上了synchronized，但是还是同时运行起来，貌似synchronized没起作用。 ```

将test()方法上的synchronized去掉，在方法内部加上synchronized(this)：

    public void test() {  
        synchronized(this){  
            System.out.println("test开始..");  
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
            System.out.println("test结束..");  
        }  
    }  

结果：

    test开始..
    test开始..
    test开始..
    test结束..
    test结束..
    test结束..

    Process finished with exit code 0


### 源码
参考源代码：com.lulj.web.synctest下：</br>
[源码：https://github.com/lulongji/ThreadDemo.git](https://github.com/lulongji/ThreadDemo.git)