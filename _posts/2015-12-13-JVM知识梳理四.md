---
layout:     post
title:      JVM知识梳理四
subtitle:   java类的加载机制
date:       2015-12-13
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - JVM
---


# java类的加载机制


        1 加载.class文件的方式
        1.1 从本地系统中直接加载
        1.2 通过网络下载.class文件
        1.3 从zip，jar等归档文件中加载.class文件
        1.4  从专有数据库中提取.class文件
        1.5 将Java源文件动态编译为.class文件
        2 类的生命周期
        2.1 加载
            2.1.1 查找并加载类的二进制数据
                2.1.1.1 通过一个类的全限定名来获取其定义的二进制字节流。
                2.1.1.2 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
                2.1.1.3 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。
        2.2 验证
            2.2.1 确保被加载的类的正确性
                2.2.1.1 文件格式验证
                2.2.1.2 元数据验证
                2.2.1.3 字节码验证
                2.2.1.4 符号引用验证
        2.3 准备
            2.3.1 为类的静态变量分配内存，并将其初始化为默认值
                2.3.1.1 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
                2.3.1.2 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。
                        2.3.1.2.1 对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。
                        2.3.1.2.2 对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值
                        2.3.1.2.3 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。
                        2.3.1.2.4 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。
                2.3.1.3 如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
        2.4 解析
            2.4.1 把类中的符号引用转换为直接引用
        2.5 初始化
            2.5.1 主要对类变量进行初始化
                2.5.1.1 声明类变量是指定初始值
                2.5.1.2 使用静态代码块为类变量指定初始值
            2.5.2  JVM初始化步骤
                2.5.2.1 假如这个类还没有被加载和连接，则程序先加载并连接该类
                2.5.2.2 假如该类的直接父类还没有被初始化，则先初始化其直接父类
                2.5.2.3 假如类中有初始化语句，则系统依次执行这些初始化语句
            2.5.3 类初始化时机
                2.5.3.1 只有当对类的主动使用的时候才会导致类的初始化
                        2.5.3.1.1  创建类的实例，也就是new的方式
                        2.5.3.1.2  访问某个类或接口的静态变量，或者对该静态变量赋值
                        2.5.3.1.3 调用类的静态方法
                        2.5.3.1.4 反射（如Class.forName(“com.shengsiyuan.Test”)）
                        2.5.3.1.5  初始化某个类的子类，则其父类也会被初始化
                        2.5.3.1.6  Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
        2.6 结束生命周期
            2.6.1 执行了System.exit()方法
            2.6.2 程序正常执行结束
            2.6.3 程序在执行过程中遇到了异常或错误而异常终止
            2.6.4  由于操作系统出现错误而导致Java虚拟机进程终止
        3 类加载器
        3.1 启动类加载器（Bootstrap ClassLoader）
            3.1.1 负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。
        3.2 扩展类加载器（Extension ClassLoader）
            3.2.1 该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载DK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。
        3.3 应用程序类加载器（Application ClassLoader）
            3.3.1 该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器
        4 JVM类加载机制
        4.1 全盘负责
            4.1.1 当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
        4.2 父类委托
            4.2.1 先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
        4.3 缓存机制
            4.3.1 缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效
        5 类的加载
        5.1 命令行启动应用时候由JVM初始化加载
        5.2 通过Class.forName()方法动态加载
            5.2.1 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块
        5.3 通过ClassLoader.loadClass()方法动态加载
            5.3.1 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。
        6 双亲委派模型
        6.1 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。
        6.2 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。
        6.3 如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；
        6.4 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。

# 图

![java类的加载机制](https://raw.githubusercontent.com/lulongji/lulongji.github.io/master/imgs/jvm/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.png)