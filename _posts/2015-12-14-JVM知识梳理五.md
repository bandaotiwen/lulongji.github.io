---
layout:     post
title:      JVM [Virtual machine performance monitoring and fault handling tools]
subtitle:   虚拟机性能监控与故障处理工具
date:       2015-12-14
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
    - JVM
---


# JDK监控和故障处理工具

在jdk安装目录../jdk/bin目录下，有我们熟悉的java和javac命令，还有用于监控虚拟机和故障处理的工具。

- jps：JVM Process Status Tool ,显示指定系统内所有的HotSpot虚拟机进程
- jstat: JVM Statistics Monitoring Tool ,用于收集HotSpot虚拟机各方面的运行数据。
- jinfo: Configuration Info forJava,显示虚拟机配置信息
- jmap: Memory Map for Java，生成虚拟机的内存转储快照（heapdump文件）
- jhat: JVM Heap Dump Browser ,用于分析heapdump文件，它会建立一个HTTP/HTML服务器，让用户可以在浏览器上查看分析结果
- jstack: Stack Trace forJava，显示虚拟机的线程快照


### jps
虚拟机进程状况工具,jps是用于查看有权访问的hotspot虚拟机的进程. 当未指定hostid时，默认查看本机jvm进程，否者查看指定的hostid机器上的jvm进程，此时hostid所指机器必须开启jstatd服务。 jps可以列出jvm进程lvmid，主类类名，main函数参数, jvm参数，jar名称等信息。

没添加option的时候，默认列出VM标示符号和简单的class或jar名称:

    [root@179-180-ty bin]# jps
    30292 QuorumPeerMain
    10166 cplatform.jar
    2630 Bootstrap
    31607 wxopen.jar
    32744 Jps
    31832 wxrest.jar
    3641 Bootstrap
    32121 ccgw.jar
    26574 Bootstrap
    1951 ECConnector
    1423 ECAuthServer

-p  :仅仅显示VM 标示，不显示jar,class, main参数等信息.

    [root@179-180-ty bin]# jps -q
    30292
    10166
    2630
    31607
    31832
    3641
    32121
    302
    26574
    1951
    1423

-m:输出主函数传入的参数.

    [root@179-180-ty bin]# jps -m
    30292 QuorumPeerMain /app/zookeeper/server/bin/../conf/zoo.cfg
    10166 cplatform.jar
    2630 Bootstrap start
    31607 wxopen.jar
    31832 wxrest.jar
    3641 Bootstrap start
    32121 ccgw.jar
    317 Jps -m
    26574 Bootstrap start
    1951 ECConnector
    1423 ECAuthServer

-l: 输出应用程序主类完整package名称或jar完整名称.

    [root@179-180-ty bin]# jps -l
    30292 org.apache.zookeeper.server.quorum.QuorumPeerMain
    10166 /app/springboot_cplatform/cplatform.jar
    2630 org.apache.catalina.startup.Bootstrap
    31607 /app/springboot_wxopen/wxopen.jar
    31832 /app/springboot_wxrest/wxrest.jar
    3641 org.apache.catalina.startup.Bootstrap
    32121 /app/springboot_ccgw/ccgw.jar
    332 sun.tools.jps.Jps
    26574 org.apache.catalina.startup.Bootstrap
    1951 com.yuntongxun.connector.ECConnector
    1423 com.yuntongxun.auth.ECAuthServer


-v: 列出jvm参数, -Xms20m -Xmx50m是启动程序指定的jvm参数

    [root@179-180-ty bin]# jps -v
    30292 QuorumPeerMain -Dzookeeper.log.dir=. -Dzookeeper.root.logger=INFO,CONSOLE -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=false
    10166 cplatform.jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8998 -Dname=cplatform -Djeesuite.configcenter.profile=dev -Duser.timezone=Asia/Shanghai -Xms1g -Xmx1g -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:/app/springboot_cplatform/logs/gclog/gc-cplatform-20190109175836.log -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC
    2630 Bootstrap -Djava.util.logging.config.file=/app/tomcat-websocket/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Dignore.endorsed.dirs= -Dcatalina.base=/app/tomcat-websocket -Dcatalina.home=/app/tomcat-websocket -Djava.io.tmpdir=/app/tomcat-websocket/temp
    31607 wxopen.jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8999 -Dname=wxopen -Djeesuite.configcenter.profile=dev -Duser.timezone=Asia/Shanghai -Xms1g -Xmx1g -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:/app/springboot_wxopen/logs/gclog/gc-wxopen-20190213102035.log -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC
    31832 wxrest.jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8899 -Dname=wxrest -Djeesuite.configcenter.profile=dev -Duser.timezone=Asia/Shanghai -Xms1g -Xmx1g -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:/app/springboot_wxrest/logs/gclog/gc-wxrest-20190213102619.log -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC
    344 Jps -Denv.class.path=.:/app/jdk/lib/dt.jar:/app/jdk/lib/tools.jar -Dapplication.home=/usr/local/java/jdk1.8.0_171 -Xms8m
    3641 Bootstrap -Djava.util.logging.config.file=/app/tomcat-fileserver/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9991 -Djava.endorsed.dirs=/app/tomcat-fileserver/endorsed -Dcatalina.base=/app/tomcat-fileserver -Dcatalina.home=/app/tomcat-fileserver -Djava.io.tmpdir=/app/tomcat-fileserver/temp
    32121 ccgw.jar -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=9999 -Dname=ccgw -Djeesuite.configcenter.profile=dev -Duser.timezone=Asia/Shanghai -Xms2g -Xmx2g -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:/app/springboot_ccgw/logs/gc-ccgw-20190213111655.log -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC
    26574 Bootstrap -Djava.util.logging.config.file=/app/tomcat-mcmserver/conf/logging.properties -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager -Djdk.tls.ephemeralDHKeySize=2048 -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8787 -Dignore.endorsed.dirs= -Dcatalina.base=/app/tomcat-mcmserver -Dcatalina.home=/app/tomcat-mcmserver -Djava.io.tmpdir=/app/tomcat-mcmserver/temp
    1951 ECConnector -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=2222 -Xms2048M -Xmx2048M -XX:PermSize=256M -XX:MaxPermSize=512M -XX:NewRatio=4 -XX:+UseParallelGC -XX:ParallelGCThreads=8 -XX:+UseAdaptiveSizePolicy -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:-HeapDumpOnOutOfMemoryError -Xloggc:verbose-gc-sp.txt
    1423 ECAuthServer -Xms1024m -Xmx1024m -XX:MaxPermSize=256m -XX:NewRatio=4 -XX:+UseParallelGC -XX:ParallelGCThreads=8 -XX:+UseAdaptiveSizePolicy -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -XX:-HeapDumpOnOutOfMemoryError -Xloggc:verbose-gc-sp.txt


-V: 输出通过.hotsportrc或-XX:Flags=<filename>指定的jvm参数

    [root@179-180-ty bin]# jps -V
    30292 QuorumPeerMain
    357 Jps
    10166 cplatform.jar
    2630 Bootstrap
    31607 wxopen.jar
    31832 wxrest.jar
    3641 Bootstrap
    32121 ccgw.jar
    26574 Bootstrap
    1951 ECConnector
    1423 ECAuthServer


### jstat

使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供RMI支持）虚拟机进程中的类信息、内存、垃圾收集、JIT编译等运行数据，在没有GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。

    lu@localhost ~$ jstat -options
    -class
    -compiler
    -gc
    -gccapacity
    -gccause
    -gcmetacapacity
    -gcnew
    -gcnewcapacity
    -gcold
    -gcoldcapacity
    -gcutil
    -printcompilation


option   可以从下面参数中选择

    -class                 显示ClassLoad的相关信息；
    -compiler           显示JIT编译的相关信息；
    -gc                     显示和gc相关的堆信息；
    -gccapacity 　　  显示各个代的容量以及使用情况；
    -gcmetacapacity 显示metaspace的大小
    -gcnew               显示新生代信息；
    -gcnewcapacity  显示新生代大小和使用情况；
    -gcold                 显示老年代和永久代的信息；
    -gcoldcapacity    显示老年代的大小；
    -gcutil　　           显示垃圾收集信息；
    -gccause             显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；
    -printcompilation 输出JIT编译的方法信息；


###### 示例

``` -class ```

    jstat -class <pid>

如下：

    [root@179-180-ty bin]# jps -l
    30292 org.apache.zookeeper.server.quorum.QuorumPeerMain
    10166 /app/springboot_cplatform/cplatform.jar
    2630 org.apache.catalina.startup.Bootstrap
    31607 /app/springboot_wxopen/wxopen.jar
    31832 /app/springboot_wxrest/wxrest.jar
    3641 org.apache.catalina.startup.Bootstrap
    32121 /app/springboot_ccgw/ccgw.jar
    573 sun.tools.jps.Jps
    26574 org.apache.catalina.startup.Bootstrap
    1951 com.yuntongxun.connector.ECConnector
    1423 com.yuntongxun.auth.ECAuthServer
    [root@179-180-ty bin]# jstat -class 31607
    Loaded  Bytes  Unloaded  Bytes     Time
    10077 18693.4        0     0.0      16.85

说明：

    Loaded : 已经装载的类的数量
    Bytes : 装载类所占用的字节数
    Unloaded：已经卸载类的数量
    Bytes：卸载类的字节数
    Time：装载和卸载类所花费的时间


```-compiler```

    jstat -compiler <pid>

如下：

    [root@179-180-ty bin]# jstat -compiler  31607
    Compiled Failed Invalid   Time   FailedType FailedMethod
        6581      5       0    31.08          1 com/sun/beans/TypeResolver prepare

说明：

    Compiled：编译任务执行数量
    Failed：编译任务执行失败数量
    Invalid ：编译任务执行失效数量
    Time ：编译任务消耗时间
    FailedType：最后一个编译失败任务的类型
    FailedMethod：最后一个编译失败任务所在的类及方法


```-gc```
显示gc相关的堆信息，查看gc的次数，及时间

    jstat –gc <pid>

如下：

    [root@179-180-ty bin]# jstat -gc  31607
    S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT
    16384.0 16384.0 16360.3  0.0   491520.0 112385.7  524288.0   46920.1   57344.0 55107.9 7168.0 6751.9      6    0.398   2      0.149    0.547


说明：

    S0C：年轻代中第一个survivor（幸存区）的容量 （字节）
    S1C：年轻代中第二个survivor（幸存区）的容量 (字节)
    S0U   ：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
    S1U     ：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)
    EC      ：年轻代中Eden（伊甸园）的容量 (字节)
    EU       ：年轻代中Eden（伊甸园）目前已使用空间 (字节)
    OC        ：Old代的容量 (字节)
    OU      ：Old代目前已使用空间 (字节)
    MC：metaspace(元空间)的容量 (字节)
    MU：metaspace(元空间)目前已使用空间 (字节)
    YGC    ：从应用程序启动到采样时年轻代中gc次数
    YGCT   ：从应用程序启动到采样时年轻代中gc所用时间(s)
    FGC   ：从应用程序启动到采样时old代(全gc)gc次数
    FGCT    ：从应用程序启动到采样时old代(全gc)gc所用时间(s)
    GCT：从应用程序启动到采样时gc用的总时间(s)


``` -gccapacity```
可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小

    jstat -gccapacity <pid>

如下：

    [root@179-180-ty bin]# jstat -gccapacity  31607
    NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC
    524288.0 524288.0 524288.0 16384.0 16384.0 491520.0   524288.0   524288.0   524288.0   524288.0      0.0 1099776.0  57344.0      0.0 1048576.0   7168.0      6     2


说明：

    NGCMN   ：年轻代(young)中初始化(最小)的大小(字节)
    NGCMX    ：年轻代(young)的最大容量 (字节)
    NGC    ：年轻代(young)中当前的容量 (字节)
    S0C  ：年轻代中第一个survivor（幸存区）的容量 (字节)
    S1C  ：    年轻代中第二个survivor（幸存区）的容量 (字节)
    EC    ：年轻代中Eden（伊甸园）的容量 (字节)
    OGCMN     ：old代中初始化(最小)的大小 (字节)
    OGCMX      ：old代的最大容量(字节)
    OGC：old代当前新生成的容量 (字节)
    OC     ：Old代的容量 (字节)
    MCMN：metaspace(元空间)中初始化(最小)的大小 (字节)
    MCMX ：metaspace(元空间)的最大容量 (字节)
    MC ：metaspace(元空间)当前新生成的容量 (字节)
    CCSMN：最小压缩类空间大小
    CCSMX：最大压缩类空间大小
    CCSC：当前压缩类空间大小
    YGC   ：从应用程序启动到采样时年轻代中gc次数
    FGC：从应用程序启动到采样时old代(全gc)gc次数


``` -gcmetacapacity```
metaspace 中对象的信息及其占用量。

    jstat -gcmetacapacity <pid>

如下：

    [root@179-180-ty bin]# jstat -gcmetacapacity  31607
    MCMN       MCMX        MC       CCSMN      CCSMX       CCSC     YGC   FGC    FGCT     GCT
        0.0  1099776.0    57344.0        0.0  1048576.0     7168.0     6     2    0.149    0.547


说明：

    MCMN:最小元数据容量
    MCMX：最大元数据容量
    MC：当前元数据空间大小
    CCSMN：最小压缩类空间大小
    CCSMX：最大压缩类空间大小
    CCSC：当前压缩类空间大小
    YGC  ：从应用程序启动到采样时年轻代中gc次数
    FGC   ：从应用程序启动到采样时old代(全gc)gc次数
    FGCT    ：从应用程序启动到采样时old代(全gc)gc所用时间(s)
    GCT：从应用程序启动到采样时gc用的总时间(s)


``` -gcnew```
年轻代对象的信息。

    jstat -gcnew <pid>

如下：

    [root@179-180-ty bin]# jstat -gcnew  31607
    S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT
    16384.0 16384.0 16360.3    0.0  5  15 16384.0 491520.0 125364.4      6    0.398

说明：

    S0C   ：年轻代中第一个survivor（幸存区）的容量 (字节)
    S1C   ：年轻代中第二个survivor（幸存区）的容量 (字节)
    S0U   ：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
    S1U  ：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)
    TT：持有次数限制
    MTT：最大持有次数限制
    DSS：期望的幸存区大小
    EC：年轻代中Eden（伊甸园）的容量 (字节)
    EU ：年轻代中Eden（伊甸园）目前已使用空间 (字节)
    YGC ：从应用程序启动到采样时年轻代中gc次数
    YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)


```-gcnewcapacity```

年轻代对象的信息及其占用量

    jstat -gcnewcapacity <pid>

如下：

    [root@179-180-ty bin]# jstat -gcnewcapacity  31607
    NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC      YGC   FGC
    524288.0   524288.0   524288.0  16384.0  16384.0  16384.0  16384.0   523264.0   491520.0     6     2


说明：

    NGCMN     ：年轻代(young)中初始化(最小)的大小(字节)
    NGCMX      ：年轻代(young)的最大容量 (字节)
    NGC     ：年轻代(young)中当前的容量 (字节)
    S0CMX    ：年轻代中第一个survivor（幸存区）的最大容量 (字节)
    S0C    ：年轻代中第一个survivor（幸存区）的容量 (字节)
    S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节)
    S1C：年轻代中第二个survivor（幸存区）的容量 (字节)
    ECMX：年轻代中Eden（伊甸园）的最大容量 (字节)
    EC：年轻代中Eden（伊甸园）的容量 (字节)
    YGC：从应用程序启动到采样时年轻代中gc次数
    FGC：从应用程序启动到采样时old代(全gc)gc次数

``` -gcold```
old代对象的信息

    jstat -gcold <pid>

如下：

    [root@179-180-ty bin]# jstat -gcold  31607
    MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT
    57344.0  55107.9   7168.0   6751.9    524288.0     46920.1      6     2    0.149    0.547

说明：

    MC ：metaspace(元空间)的容量 (字节)
    MU：metaspace(元空间)目前已使用空间 (字节)
    CCSC:压缩类空间大小
    CCSU:压缩类空间使用大小
    OC：Old代的容量 (字节)
    OU：Old代目前已使用空间 (字节)
    YGC：从应用程序启动到采样时年轻代中gc次数
    FGC：从应用程序启动到采样时old代(全gc)gc次数
    FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)
    GCT：从应用程序启动到采样时gc用的总时间(s)

```-gcoldcapacity```
old代对象的信息及其占用量

    jstat -gcoldcapacity <pid>

如下：

    [root@179-180-ty bin]# jstat -gcoldcapacity  31607
    OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT
    524288.0    524288.0    524288.0    524288.0     6     2    0.149    0.547

说明：

    OGCMN      ：old代中初始化(最小)的大小 (字节)
    OGCMX       ：old代的最大容量(字节)
    OGC        ：old代当前新生成的容量 (字节)
    OC      ：Old代的容量 (字节)
    YGC  ：从应用程序启动到采样时年轻代中gc次数
    FGC   ：从应用程序启动到采样时old代(全gc)gc次数
    FGCT    ：从应用程序启动到采样时old代(全gc)gc所用时间(s)
    GCT：从应用程序启动到采样时gc用的总时间(s)


```-gcutil```
统计gc信息

    jstat -gcutil <pid>

如下：

    [root@179-180-ty bin]# jstat -gcutil  31607
    S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT
    99.86   0.00  27.93   8.95  96.10  94.19      6    0.398     2    0.149    0.547

说明：

    S0    ：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比
    S1    ：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比
    E     ：年轻代中Eden（伊甸园）已使用的占当前容量百分比
    O     ：old代已使用的占当前容量百分比
    P    ：perm代已使用的占当前容量百分比
    YGC  ：从应用程序启动到采样时年轻代中gc次数
    YGCT   ：从应用程序启动到采样时年轻代中gc所用时间(s)
    FGC   ：从应用程序启动到采样时old代(全gc)gc次数
    FGCT    ：从应用程序启动到采样时old代(全gc)gc所用时间(s)
    GCT：从应用程序启动到采样时gc用的总时间(s)


```-gccause```

显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因。

    jstat -gccause <pid>


如下：

    [root@179-180-ty bin]# jstat -gccause  31607
    S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC
    99.86   0.00  27.93   8.95  96.10  94.19      6    0.398     2    0.149    0.547 Allocation Failure   No GC

说明：

    LGCC：最后一次GC原因
    GCC：当前GC原因（No GC 为当前没有执行GC）


```-printcompilation```
当前VM执行的信息.

    jstat -printcompilation <pid>

如下：

    [root@179-180-ty bin]# jstat -printcompilation  31607
    Compiled  Size  Type Method
        6589    269    1 java/lang/AbstractStringBuilder append

说明：

    Compiled ：编译任务的数目
    Size ：方法生成的字节码的大小
    Type：编译类型
    Method：类名和方法名用来标识编译的方法。类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的


### jinfo

jinfo 命令可以用来查看 Java 进程运行的 JVM 参数，命令如下

    [root@179-180-ty bin]#  jinfo --help
    Usage:
        jinfo [option] <pid>
            (to connect to running process)
        jinfo [option] <executable <core>
            (to connect to a core file)
        jinfo [option] [server_id@]<remote server IP or hostname>
            (to connect to remote debug server)

    where <option> is one of:
        -flag <name>         to print the value of the named VM flag
        -flag [+|-]<name>    to enable or disable the named VM flag
        -flag <name>=<value> to set the named VM flag to the given value
        -flags               to print VM flags
        -sysprops            to print Java system properties
        <no option>          to print both of the above
        -h | -help           to print this help message
    


我们先用 jps 命令查到 PID ，然后可以通过 jinfo 来查看对应进程的参数信息：

    [root@179-180-ty bin]# jps
    30292 QuorumPeerMain
    10166 cplatform.jar
    2630 Bootstrap
    31607 wxopen.jar
    31832 wxrest.jar
    3641 Bootstrap
    32121 ccgw.jar
    826 Jps
    26574 Bootstrap
    1951 ECConnector
    1423 ECAuthServer

```-flags ```

    [root@179-180-ty bin]# jinfo -flags 31607
    Attaching to process ID 31607, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.171-b11
    Non-default VM flags: -XX:CICompilerCount=2 -XX:+HeapDumpOnOutOfMemoryError -XX:InitialHeapSize=1073741824 -XX:MaxHeapSize=1073741824 -XX:MaxNewSize=536870912 -XX:MinHeapDeltaBytes=524288 -XX:NewRatio=1 -XX:NewSize=536870912 -XX:OldSize=536870912 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=30 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:+UseParallelGC -XX:+UseParallelOldGC
    Command line:  -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8999 -Dname=wxopen -Djeesuite.configcenter.profile=dev -Duser.timezone=Asia/Shanghai -Xms1g -Xmx1g -XX:PermSize=256M -XX:MaxPermSize=512M -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:/app/springboot_wxopen/logs/gclog/gc-wxopen-20190213102035.log -XX:+PrintGCDetails -XX:NewRatio=1 -XX:SurvivorRatio=30 -XX:+UseParallelGC -XX:+UseParallelOldGC



```其他示例请自行测试。```

### jmap

jmap命令可以获得运行中的jvm的堆的快照，从而可以离线分析堆，以检查内存泄漏，检查一些严重影响性能的大对象的创建，检查系统中什么对象最多，各种对象所占内存的大小等等。可以使用jmap生成Heap Dump。 


    [root@179-180-ty bin]# jmap -help
    Usage:
        jmap [option] <pid>
            (to connect to running process)
        jmap [option] <executable <core>
            (to connect to a core file)
        jmap [option] [server_id@]<remote server IP or hostname>
            (to connect to remote debug server)

    where <option> is one of:
        <none>               to print same info as Solaris pmap
        -heap                to print java heap summary
        -histo[:live]        to print histogram of java object heap; if the "live"
                            suboption is specified, only count live objects
        -clstats             to print class loader statistics
        -finalizerinfo       to print information on objects awaiting finalization
        -dump:<dump-options> to dump java heap in hprof binary format
                            dump-options:
                            live         dump only live objects; if not specified,
                                            all objects in the heap are dumped.
                            format=b     binary format
                            file=<file>  dump heap to <file>
                            Example: jmap -dump:live,format=b,file=heap.bin <pid>
        -F                   force. Use with -dump:<dump-options> <pid> or -histo
                            to force a heap dump or histogram when <pid> does not
                            respond. The "live" suboption is not supported
                            in this mode.
        -h | -help           to print this help message
        -J<flag>             to pass <flag> directly to the runtime system



参数：

    option： 选项参数。

    pid： 需要打印配置信息的进程ID。

    executable： 产生核心dump的Java可执行文件。

    core： 需要打印配置信息的核心文件。

    server-id 可选的唯一id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。

    remote server IP or hostname 远程调试服务器的IP地址或主机名。

option

    no option： 查看进程的内存映像信息,类似 Solaris pmap 命令。

    heap： 显示Java堆详细信息

    histo[:live]： 显示堆中对象的统计信息

    clstats：打印类加载器信息

    finalizerinfo： 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象

    dump:<dump-options>：生成堆转储快照

    F： 当-dump没有响应时，使用-dump或者-histo参数. 在这个模式下,live子参数无效.

    help：打印帮助信息

    J<flag>：指定传递给运行jmap的JVM的参数


``` no option```

    [root@179-180-ty bin]# jmap 31607
    Attaching to process ID 31607, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.171-b11
    0x0000000000400000	7K	/usr/local/java/jdk1.8.0_171/bin/java
    0x00002ae08de43000	155K	/lib64/ld-2.12.so
    0x00002ae08e066000	139K	/lib64/libpthread-2.12.so
    0x00002ae08e284000	101K	/usr/local/java/jdk1.8.0_171/lib/amd64/jli/libjli.so
    0x00002ae08e49a000	19K	/lib64/libdl-2.12.so
    0x00002ae08e69e000	1879K	/lib64/libc-2.12.so
    0x00002ae08ea34000	16646K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/server/libjvm.so
    0x00002ae08fa43000	582K	/lib64/libm-2.12.so
    0x00002ae08fdda000	43K	/lib64/librt-2.12.so
    0x00002ae094000000	64K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libverify.so
    0x00002ae09420f000	221K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libjava.so
    0x00002ae09443e000	265K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libjdwp.so
    0x00002ae094679000	14K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libnpt.so
    0x00002ae09a724000	64K	/lib64/libnss_files-2.12.so
    0x00002ae09a932000	125K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libzip.so
    0x00002ae0aabe8000	49K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libmanagement.so
    0x00002ae0aadf1000	112K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libnet.so
    0x00002ae0abd1c000	91K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libnio.so
    0x00002ae0bc303000	21K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libdt_socket.so
    0x00002ae0f1b18000	251K	/usr/local/java/jdk1.8.0_171/jre/lib/amd64/libsunec.so
    0x00002ae0f1d71000	88K	/lib64/libgcc_s-4.4.7-20120601.so.1

说明：

    查看进程的内存映像信息,类似 Solaris pmap 命令。

```heap```

命令：

    jmap -heap pid

描述：

    显示Java堆详细信息

示例：

    [root@179-180-ty bin]# jmap -heap 31607
    Attaching to process ID 31607, please wait...
    Debugger attached successfully.
    Server compiler detected.
    JVM version is 25.171-b11

    using thread-local object allocation.
    Parallel GC with 2 thread(s)

    Heap Configuration:
        MinHeapFreeRatio         = 0
        MaxHeapFreeRatio         = 100
        MaxHeapSize              = 1073741824 (1024.0MB)
        NewSize                  = 536870912 (512.0MB)
        MaxNewSize               = 536870912 (512.0MB)
        OldSize                  = 536870912 (512.0MB)
        NewRatio                 = 1
        SurvivorRatio            = 30
        MetaspaceSize            = 21807104 (20.796875MB)
        CompressedClassSpaceSize = 1073741824 (1024.0MB)
        MaxMetaspaceSize         = 17592186044415 MB
        G1HeapRegionSize         = 0 (0.0MB)

    Heap Usage:
    PS Young Generation
    Eden Space:
        capacity = 503316480 (480.0MB)
        used     = 166649200 (158.92906188964844MB)
        free     = 336667280 (321.07093811035156MB)
        33.11022122701009% used
    From Space:
        capacity = 16777216 (16.0MB)
        used     = 16752928 (15.976837158203125MB)
        free     = 24288 (0.023162841796875MB)
        99.85523223876953% used
    To Space:
        capacity = 16777216 (16.0MB)
        used     = 0 (0.0MB)
        free     = 16777216 (16.0MB)
        0.0% used
    PS Old Generation
        capacity = 536870912 (512.0MB)
        used     = 48046144 (45.82037353515625MB)
        free     = 488824768 (466.17962646484375MB)
        8.949291706085205% used

    23653 interned Strings occupying 2884720 bytes.


```其他示例请自行测试。```


### jhat

jhat也是jdk内置的工具之一。主要是用来分析java堆的命令，可以将堆中的对象以html的形式显示出来，包括对象的数量，大小等等，并支持对象查询语言。

使用jmap等方法生成java的堆文件后，使用其进行分析
1. 导出堆

        jmap -dump:live,file=a.log pid

2. 分析堆文件

        jhat -J-Xmx512M a.log

```说明：有时dump出来的堆很大，在启动时会报堆空间不足的错误，可加参数：jhat -J-Xmx512m <heap dump file>。这个内存大小可根据自己电脑进行设置。```


操作示例：

    [root@179-180-ty bin]# jps
    30292 QuorumPeerMain
    10166 cplatform.jar
    2630 Bootstrap
    31607 wxopen.jar
    31832 wxrest.jar
    3641 Bootstrap
    32121 ccgw.jar
    1005 Jps
    26574 Bootstrap
    1951 ECConnector
    1423 ECAuthServer
    [root@179-180-ty bin]# jmap -dump:live,file=a.log 31607
    Dumping heap to /usr/local/java/jdk1.8.0_171/bin/a.log ...
    Heap dump file created
    [root@179-180-ty bin]# jhat -J-Xmx512M a.log
    Reading from a.log...
    Dump file created Wed Feb 13 17:21:56 CST 2019
    Snapshot read, resolving...
    Resolving 473586 objects...
    Chasing references, expect 94 dots..............................................................................................
    Eliminating duplicate references..............................................................................................
    Snapshot resolved.
    Started HTTP server on port 7000
    Server is ready.


访问：

    http://localhost:7000/



### jstack

命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.


    [root@179-180-ty ~]# jstack -help
    Usage:
        jstack [-l] <pid>
            (to connect to running process)
        jstack -F [-m] [-l] <pid>
            (to connect to a hung process)
        jstack [-m] [-l] <executable> <core>
            (to connect to a core file)
        jstack [-m] [-l] [server_id@]<remote server IP or hostname>
            (to connect to a remote debug server)

    Options:
        -F  to force a thread dump. Use when jstack <pid> does not respond (process is hung)
        -m  to print both java and native frames (mixed mode)
        -l  long listing. Prints additional information about locks
        -h or -help to print this help message



操作示例：

    [root@179-180-ty ~]# jps
    30292 QuorumPeerMain
    10166 cplatform.jar
    2630 Bootstrap
    31607 wxopen.jar
    31832 wxrest.jar
    3641 Bootstrap
    32121 ccgw.jar
    26574 Bootstrap
    1951 ECConnector
    2943 Jps
    1423 ECAuthServer
    [root@179-180-ty ~]# jstack 31607
    2019-02-14 09:38:04
    Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.171-b11 mixed mode):

    "Attach Listener" #36 daemon prio=9 os_prio=0 tid=0x00002ae0c8004800 nid=0x3c2 waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "DestroyJavaVM" #35 prio=5 os_prio=0 tid=0x00002ae09000c000 nid=0x7b79 waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "http-nio-8896-AsyncTimeout" #33 daemon prio=5 os_prio=0 tid=0x00002ae09244b000 nid=0x7b9d waiting on condition [0x00002ae0f170d000]
    java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at org.apache.coyote.AbstractProtocol$AsyncTimeout.run(AbstractProtocol.java:1133)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-Acceptor-0" #32 daemon prio=5 os_prio=0 tid=0x00002ae09075d800 nid=0x7b9c runnable [0x00002ae0f160c000]
    java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.ServerSocketChannelImpl.accept0(Native Method)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:422)
        at sun.nio.ch.ServerSocketChannelImpl.accept(ServerSocketChannelImpl.java:250)
        - locked <0x00000000c0f18ba8> (a java.lang.Object)
        at org.apache.tomcat.util.net.NioEndpoint$Acceptor.run(NioEndpoint.java:455)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-ClientPoller-1" #31 daemon prio=5 os_prio=0 tid=0x00002ae09111c000 nid=0x7b9b runnable [0x00002ae0f150b000]
    java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
        at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
        - locked <0x00000000c0f385e8> (a sun.nio.ch.Util$3)
        - locked <0x00000000c0f385d8> (a java.util.Collections$UnmodifiableSet)
        - locked <0x00000000c0f38390> (a sun.nio.ch.EPollSelectorImpl)
        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
        at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:796)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-ClientPoller-0" #30 daemon prio=5 os_prio=0 tid=0x00002ae091e99800 nid=0x7b9a runnable [0x00002ae0f140a000]
    java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
        at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
        - locked <0x00000000c0f37e68> (a sun.nio.ch.Util$3)
        - locked <0x00000000c0f37e58> (a java.util.Collections$UnmodifiableSet)
        - locked <0x00000000c0f37c10> (a sun.nio.ch.EPollSelectorImpl)
        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
        at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:796)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-10" #29 daemon prio=5 os_prio=0 tid=0x00002ae0ec862800 nid=0x7b99 waiting on condition [0x00002ae0f1309000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-9" #28 daemon prio=5 os_prio=0 tid=0x00002ae0ec860800 nid=0x7b98 waiting on condition [0x00002ae0f1208000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-8" #27 daemon prio=5 os_prio=0 tid=0x00002ae0ec983800 nid=0x7b97 waiting on condition [0x00002ae0f1107000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-7" #26 daemon prio=5 os_prio=0 tid=0x00002ae0ec981800 nid=0x7b96 waiting on condition [0x00002ae0f1006000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-6" #25 daemon prio=5 os_prio=0 tid=0x00002ae0ecb49800 nid=0x7b95 waiting on condition [0x00002ae0f0f05000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-5" #24 daemon prio=5 os_prio=0 tid=0x00002ae0ecb48000 nid=0x7b94 waiting on condition [0x00002ae0f0e04000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-4" #23 daemon prio=5 os_prio=0 tid=0x00002ae092601800 nid=0x7b93 waiting on condition [0x00002ae0f0d03000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-3" #22 daemon prio=5 os_prio=0 tid=0x00002ae0ecbd7800 nid=0x7b92 waiting on condition [0x00002ae0f0c02000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-2" #21 daemon prio=5 os_prio=0 tid=0x00002ae0ecbd5800 nid=0x7b91 waiting on condition [0x00002ae0f0b01000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "http-nio-8896-exec-1" #20 daemon prio=5 os_prio=0 tid=0x00002ae0ecbd4800 nid=0x7b90 waiting on condition [0x00002ae0bfff4000]
    java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c0e22398> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)
        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:103)
        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:31)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
        at java.lang.Thread.run(Thread.java:748)

    "NioBlockingSelector.BlockPoller-1" #19 daemon prio=5 os_prio=0 tid=0x00002ae090e3b000 nid=0x7b8f runnable [0x00002ae0f04ff000]
    java.lang.Thread.State: RUNNABLE
        at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
        at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
        at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
        at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
        - locked <0x00000000c0f183c8> (a sun.nio.ch.Util$3)
        - locked <0x00000000c0f183b8> (a java.util.Collections$UnmodifiableSet)
        - locked <0x00000000c0f18280> (a sun.nio.ch.EPollSelectorImpl)
        at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
        at org.apache.tomcat.util.net.NioBlockingSelector$BlockPoller.run(NioBlockingSelector.java:298)

    "commons-pool-evictor-thread" #18 prio=5 os_prio=0 tid=0x00002ae090506000 nid=0x7b8e waiting on condition [0x00002ae0f0600000]
    java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x00000000c108e338> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1093)
        at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:809)
        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1074)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1134)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
        at java.lang.Thread.run(Thread.java:748)

    "container-0" #16 prio=5 os_prio=0 tid=0x00002ae0915f0800 nid=0x7b8c waiting on condition [0x00002ae0bfef3000]
    java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at org.apache.catalina.core.StandardServer.await(StandardServer.java:427)
        at org.springframework.boot.web.embedded.tomcat.TomcatWebServer$1.run(TomcatWebServer.java:182)

    "ContainerBackgroundProcessor[StandardEngine[Tomcat]]" #15 daemon prio=5 os_prio=0 tid=0x00002ae0906c5800 nid=0x7b8b waiting on condition [0x00002ae0abc20000]
    java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1357)
        at java.lang.Thread.run(Thread.java:748)

    "Service Thread" #9 daemon prio=9 os_prio=0 tid=0x00002ae090153800 nid=0x7b84 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "C1 CompilerThread1" #8 daemon prio=9 os_prio=0 tid=0x00002ae090150000 nid=0x7b83 waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "C2 CompilerThread0" #7 daemon prio=9 os_prio=0 tid=0x00002ae09014d000 nid=0x7b82 waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "JDWP Event Helper Thread" #6 daemon prio=10 os_prio=0 tid=0x00002ae09014b000 nid=0x7b81 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "JDWP Transport Listener: dt_socket" #5 daemon prio=10 os_prio=0 tid=0x00002ae090147800 nid=0x7b80 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "Signal Dispatcher" #4 daemon prio=9 os_prio=0 tid=0x00002ae09013b800 nid=0x7b7f runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE

    "Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00002ae090109800 nid=0x7b7e in Object.wait() [0x00002ae0bc200000]
    java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00000000c00efe00> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
        - locked <0x00000000c00efe00> (a java.lang.ref.ReferenceQueue$Lock)
        at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
        at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:212)

    "Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00002ae090105000 nid=0x7b7d in Object.wait() [0x00002ae0bc0ff000]
    java.lang.Thread.State: WAITING (on object monitor)
        at java.lang.Object.wait(Native Method)
        - waiting on <0x00000000c00efe40> (a java.lang.ref.Reference$Lock)
        at java.lang.Object.wait(Object.java:502)
        at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
        - locked <0x00000000c00efe40> (a java.lang.ref.Reference$Lock)
        at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

    "VM Thread" os_prio=0 tid=0x00002ae0900fd000 nid=0x7b7c runnable

    "GC task thread#0 (ParallelGC)" os_prio=0 tid=0x00002ae090021800 nid=0x7b7a runnable

    "GC task thread#1 (ParallelGC)" os_prio=0 tid=0x00002ae090023000 nid=0x7b7b runnable

    "VM Periodic Task Thread" os_prio=0 tid=0x00002ae090159000 nid=0x7b85 waiting on condition

    JNI global references: 9169



说明：

    runnable:状态一般为RUNNABLE。
    in Object.wait():等待区等待,状态为WAITING或TIMED_WAITING。
    waiting for monitor entry:进入区等待,状态为BLOCKED。
    waiting on condition:等待区等待、被park。
    sleeping:休眠的线程,调用了Thread.sleep()。

请根据相应信息结合代码进行推断和判断问题。


### jconsole

从Java 5开始 引入了 JConsole，JConsole 是一个内置 Java 性能分析器，还有一个比它更高端的 “近亲” jvisualvm 

[JConsole使用](https://www.cnblogs.com/baihuitestsoftware/articles/6405580.html)

[Jvisualvm使用](http://blog.51cto.com/zero01/2141942)


### btrace

Btrace是一个实时监控工具，可以无需修改应用代码（事实上它修改了字节码），来达到不可告人的秘密！这是性能调优和诊断的利器!

它可以获取应用程序代码的执行时间，他可以让你无需修改代码，帮你做时间的打点。它还可以做的有很多多！

但是，你需要编写btrace脚本，它是一个java文件。在Eclipse中编写java类很简单，在linux上，vm不熟悉的可能就会比较痛苦了，并且脚本可复制性很强。

因此，我对btrace做了一个封装和拓展，你无须再编写java脚本，只需要敲几个命令，便可以实现你想要的功能！

为了减少重复工作的增加，拓展工具提供了以下特色功能：

1） 命令行交互式方式

2） 封装了常见的方法监控命令，无需再编写btrace脚本

3） 集成了一些典型的监控对象，如druid连接池，sql监控，isearch等

4） 未改变原有的btrace功能，仍然支持btrace脚本方式

[btrace使用](https://github.com/xxzmxx/btrace_extend/)


### TProfiler

[TProfiler 的下载安装](https://github.com/alibaba/TProfiler)

[TProfiler配置和使用](https://yq.aliyun.com/articles/574496)



# 说明

本文只做学习参考，如有任何不准确的地方欢迎指正。

我的邮箱：
- ```lulongji2011@163.com```
