---
layout:     post
title:      设计模式之工厂模式
subtitle:   工厂模式
date:       2017-10-10
author:     lulongji
header-img: img/post-bg-hacker.jpg
catalog: true
tags:
   - 设计模式
   - 工厂模式
---


# 介绍
为什么要用工厂模式？

### 举个栗子

我们先写一段代码进行mysql数据库访问:

新建User类对应User表：

    public class User {

    private String id;
    private String username;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", username='" + username + '\'' +
                '}';
    }
}

通过MysqlUser类调用对数据库的操作：

    public class MysqlUser {

        public void insert(User user) {
            System.out.println("对 MySQL 里的 User 表插入了一条数据");
        }

        public User getUser(int uid) {
            System.out.println("通过 uid 在 MySQL 里的 User 表得到了一条数据");
            return null;
        }
    }


Client客户端调用：

    public static void main(String[] args) {

        User user = new User();
        MysqlUser mysqlUser = new MysqlUser();
        mysqlUser.insert(user);
        mysqlUser.getUser(1);
    }


```从以上的客户端代码可以很明显到看到一个问题，就是MysqlUser mysqlUser=new MysqlUser();这一句代码使得mysqlUser 这个对象被写死在了MysqlUser 上。如果需求变更，数据库方面不用MySQL而改用Oracle了呢，那么与之有关联的代码都得需要进行更改。```


### 工厂方法模式进行重构

通过工厂方法模式可以封装 new MysqlUser().


    public interface UserService {

        public void insert(User user);

        public UserService getUser(int uid);
    }

MysqlServiceImpl类，用于访问MySQL数据库的User表：


    public class MysqlServiceImpl implements UserService {

        public void insert(User user) {

            System.out.println("对 MySQL 里的 User 表插入了一条数据");
        }

        public User getUser(int uid) {
            System.out.println("通过 uid 在 MySQL 里的 User 表得到了一条数据");
            return null;
        }
    }

OracleServiceImpl类，用于访问Oracle数据库的User表：


    public class OracleServiceImpl implements UserService {

        public void insert(User user) {

            System.out.println("对 Oracle 里的 User 表插入了一条数据");
        }

        public User getUser(int uid) {
            System.out.println("通过 uid 在 Oracle 里的 User 表得到了一条数据");
            return null;
        }
    }


定义一个抽象的工厂接口,该工厂用于生产访问User表的对象:

    public interface IFactory {

        UserService createUser();
    }


MysqlFactory类，实现IFactory接口，用于生产 MysqlServiceImpl 的实例对象：

    public class MysqlFactory implements IFactory {

        @Override
        public UserService createUser() {
            return new MysqlServiceImpl();
        }
    }

OracleFactory 类，实现IFactory接口，用于生产 OracleServiceImpl 的实例对象：

    public class OracleFactory implements IFactory {

        @Override
        public UserService createUser() {
            return new OracleServiceImpl();
        }
    }


客户端代码:

    public static void main(String[] args) {
        User user = new User();

        IFactory factory = new MysqlFactory();
        UserService userService = factory.createUser();

        userService.getUser(1);
        userService.insert(user);
    }

```以上我们使用工厂方法模式重构的之前的代码，现在如果需求改变，要更换数据库，只需要把 MysqlFactory(); 改为 OracleFactory(); 就可以了，此时由于多态的特性，使得 UserService 接口的对象 userService 根本不知道是在访问哪个数据库，却可以在运行时很好的完成工作，这就是所谓的业务逻辑与数据访问的解耦```


# 说明

工厂模式是是java最常用的设计模式之一。这种类型的设计模式属于创建型模式，他提供了创建对象的最佳方式。

在工厂模式中，我们创建对象的时候不会像客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。


# 源码

[https://github.com/lulongji/DesignPattern.git]( https://github.com/lulongji/DesignPattern.git)